/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
package syntax_analyzer.compiler.model;

import code.*;
import syntax_analyzer.compiler.MiniJavaParser;
import syntax_analyzer.compiler.MiniJavaParserTreeConstants;
import syntax_analyzer.compiler.MiniJavaTypeCheck;
import syntax_analyzer.compiler.visitor.MiniJavaCheckVisitor;
import syntax_analyzer.compiler.visitor.MiniJavaParserVisitor;

public class SimpleNode extends BaseNode implements Node {
	protected Node parent;
	public Node[] children;
	protected int id;
	protected MiniJavaParser parser;

	public String getName() {
		return name;
	}

	public SimpleNode(int i) {
		id = i;
	}

	public SimpleNode(MiniJavaParser p, int i) {
		this(i);
		parser = p;
	}

	public void jjtOpen() {
	}

	public void jjtClose() {
	}

	public void jjtSetParent(Node n) {
		parent = n;
	}

	public Node jjtGetParent() {
		return parent;
	}

	public void jjtAddChild(Node n, int i) {
		if (children == null) {
			children = new Node[i + 1];
		} else if (i >= children.length) {
			Node c[] = new Node[i + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			children = c;
		}
		children[i] = n;
	}

	public Node jjtGetChild(int i) {
		return children[i];
	}

	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}

	/** Accept the visitor. * */
	public Object jjtAccept(MiniJavaParserVisitor visitor, Object data) {
		return visitor.visit(this, data);
	}
	public String acceptTypeCheck(MiniJavaCheckVisitor visitor, Symbol thisClass, int times){
		if(children==null){
			children=new Node[0];
		}
		if(this instanceof ASTRoot)
			return visitor.visit((ASTRoot)this, thisClass,times);
		if(this instanceof ASTMainClass)
			return visitor.visit((ASTMainClass)this, thisClass,times);
		if(this instanceof ASTMainMethodDeclaration)
			return visitor.visit((ASTMainMethodDeclaration)this, thisClass,times);
		if(this instanceof ASTClassDeclaration)
			return visitor.visit((ASTClassDeclaration)this, thisClass,times);
		if(this instanceof ASTClassExtendsDeclaration)
			return visitor.visit((ASTClassExtendsDeclaration)this, thisClass,times);
		if(this instanceof ASTVariableDeclaration)
			return visitor.visit((ASTVariableDeclaration)this, thisClass,times);
		if(this instanceof ASTMethodDeclaration)
			return visitor.visit((ASTMethodDeclaration)this, thisClass,times);
		if(this instanceof ASTFormalParameter)
			return visitor.visit((ASTFormalParameter)this, thisClass,times);
		if(this instanceof ASTType)
			return visitor.visit((ASTType)this, thisClass,times);
		if(this instanceof ASTArrayType)
			return visitor.visit((ASTArrayType)this, thisClass,times);
		if(this instanceof ASTBooleanType)
			return visitor.visit((ASTBooleanType)this, thisClass,times);
		if(this instanceof ASTIntegerType)
			return visitor.visit((ASTIntegerType)this, thisClass,times);
		if(this instanceof ASTIdentifier)
			return visitor.visit((ASTIdentifier)this, thisClass,times);
		if(this instanceof ASTStatement)
			return visitor.visit((ASTStatement)this, thisClass,times);
		if(this instanceof ASTBlock)
			return visitor.visit((ASTBlock)this, thisClass,times);
		if(this instanceof ASTAssignmentStatement)
			return visitor.visit((ASTAssignmentStatement)this, thisClass,times);
		if(this instanceof ASTArrayAssignmentStatement)
			return visitor.visit((ASTArrayAssignmentStatement)this, thisClass,times);
		if(this instanceof ASTIfStatement)
			return visitor.visit((ASTIfStatement)this, thisClass,times);
		if(this instanceof ASTWhileStatement)
			return visitor.visit((ASTWhileStatement)this, thisClass,times);
		if(this instanceof ASTPrintStatement)
			return visitor.visit((ASTPrintStatement)this, thisClass,times);
		if(this instanceof ASTExpression)
			return visitor.visit((ASTExpression)this, thisClass,times);
		if(this instanceof ASTAndExpression)
			return visitor.visit((ASTAndExpression)this, thisClass,times);
		if(this instanceof ASTCompareExpression)
			return visitor.visit((ASTCompareExpression)this, thisClass,times);
		if(this instanceof ASTPlusExpression)
			return visitor.visit((ASTPlusExpression)this, thisClass,times);
		if(this instanceof ASTMinusExpression)
			return visitor.visit((ASTMinusExpression)this, thisClass,times);
		if(this instanceof ASTTimesExpression)
			return visitor.visit((ASTTimesExpression)this, thisClass,times);
		if(this instanceof ASTArrayLookUp)
			return visitor.visit((ASTArrayLookUp)this, thisClass,times);
		if(this instanceof ASTArrayLength)
			return visitor.visit((ASTArrayLength)this, thisClass,times);
		if(this instanceof ASTMessageSend)
			return visitor.visit((ASTMessageSend)this, thisClass,times);
		if(this instanceof ASTIntegerLiteral)
			return visitor.visit((ASTIntegerLiteral)this, thisClass,times);
		if(this instanceof ASTTrueLiteral)
			return visitor.visit((ASTTrueLiteral)this, thisClass,times);
		if(this instanceof ASTFalseLiteral)
			return visitor.visit((ASTFalseLiteral)this, thisClass,times);
		if(this instanceof ASTNotExpression)
			return visitor.visit((ASTNotExpression)this, thisClass,times);
		return visitor.visit(this, thisClass,times);
	}

	/** Accept the visitor. * */
	public Object childrenAccept(MiniJavaParserVisitor visitor, Object data) {
		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				children[i].jjtAccept(visitor, data);
			}
		}
		return data;
	}

	/*
	 * You can override these two methods in subclasses of SimpleNode to
	 * customize the way the node appears when the tree is dumped. If your
	 * output uses more than one line you should override toString(String),
	 * otherwise overriding toString() is probably all you need to do.
	 */

	public String toString() {
		return MiniJavaParserTreeConstants.jjtNodeName[id];
	}

	public String toString(String prefix) {
		return prefix + toString();
	}

	/*
	 * Override this method if you want to customize how the node dumps out its
	 * children.
	 */

	public void printFileContent(int lineBegin_, int lineEnd_,
			int conlumnBegin_, int conlumnEnd_) {
		System.out.println("(" + lineBegin_ + "), " + "(" + lineEnd_ + "), ");
		System.out.println("(" + conlumnBegin_ + "), " + "(" + conlumnEnd_
				+ "), ");

		lineBegin_--;lineEnd_--;conlumnBegin_--;
		try{
			if (lineBegin_ == lineEnd_) {
				System.out.println(MiniJavaTypeCheck.fileContent.get(lineBegin_)
						.substring(conlumnBegin_, conlumnEnd_));
			} else {
				System.out.println(MiniJavaTypeCheck.fileContent.get(lineBegin_)
						.substring(conlumnBegin_));
				for (int i = lineBegin_ + 1; i < lineEnd_; i++) {
					System.out.println(MiniJavaTypeCheck.fileContent.get(i));
				}
				System.out.println(MiniJavaTypeCheck.fileContent.get(lineEnd_)
						.substring(0, conlumnEnd_));
			}
		}catch(Exception e){
			
			e.printStackTrace();
			System.out.println("");
			
		}

	}

	public String getFileContent() {
		int lineBegin_=  this.getBeginLine(); int lineEnd_ = this.getEndLine();
		int conlumnBegin_ = this.getBeginColumn(); int conlumnEnd_ = this.getEndColumn();
		String ret="";
		lineBegin_--;lineEnd_--;conlumnBegin_--;

		try{
			if (lineBegin_ == lineEnd_) {
				ret+=MiniJavaTypeCheck.fileContent.get(lineBegin_)
						.substring(conlumnBegin_, conlumnEnd_);
			} else {

				ret+=MiniJavaTypeCheck.fileContent.get(lineBegin_)
						.substring(conlumnBegin_);
				for (int i = lineBegin_ + 1; i < lineEnd_; i++) {
					ret+=MiniJavaTypeCheck.fileContent.get(i);
				}
				 	ret+=MiniJavaTypeCheck.fileContent.get(lineEnd_)
						.substring(0, conlumnEnd_);
			}
			return ret;
		}catch(Exception e){
			System.out.println("null in simple node");
			e.printStackTrace();
			return " null in simple node";
		}

	}
	
	public void dump(String prefix) {
		System.out.println(toString(prefix));
		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				Node temp = children[i];
				SimpleNode n = (SimpleNode) children[i];
	//				if (n != null) {
					printFileContent(n.getBeginLine(), n.getEndLine(),
									n.getBeginColumn(), n.getEndColumn());
					n.dump(prefix + " ");

	//			}
			}
		}
	}

	public Node[] getChildren() {
		return children;
	}
}
